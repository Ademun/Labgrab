# Визуализация работы дедупликатора слотов на примере данных

## Контекст

Дедупликатор получает на вход результаты матчинга подписок и фильтрует их, оставляя только те подписки у которых есть хотя бы один новый (ранее не виденный) слот. Это решает две проблемы:
1. Предотвращает спам уведомлениями о слотах которые уже были показаны пользователю
2. Уменьшает нагрузку на сторонний сервис, так как не обрабатываются дубликаты

## Исходные данные

### Входные параметры запроса (GetMatchingSubscriptionsReq)

```go
req := &GetMatchingSubscriptionsReq{
    LabType:       "Defence",
    LabTopic:      "Virtual",
    LabNumber:     3,
    LabAuditorium: 201,
    AvailableSlots: map[DayOfWeek]map[int][]string{
        "MON": {
            1: []string{"Ivanov", "Petrov"},
            2: []string{"Sidorov", "Kozlov"},
            3: []string{"Petrov"},
        },
        "WED": {
            2: []string{"Ivanov", "Kozlov"},
        },
    },
}
```

### Результаты матчинга ([]DBSubscriptionMatchResult)

Это результат который мы получили после выполнения GetMatchingSubscriptions:

| user_uuid | subscription_uuid | successful_subscriptions | last_successful_subscription | matching_timeslots |
|-----------|------------------|-------------------------|----------------------------|-------------------|
| user-charlie | sub-003 | 0 | NULL | {"WED": [2]} |
| user-bob | sub-002 | 2 | 2025-01-05 | {"MON": [1]} |
| user-alice | sub-001 | 5 | 2025-01-10 | {"MON": [1, 2, 3], "WED": [2]} |

### Конфигурация дедупликатора

```go
cfg := &DeduplicatorConfig{
    KeyPrefix: "slot_dedup",
    TTL:       24 * time.Hour, // 24 часа
}
```

### Состояние Redis кэша (начальное)

Предположим, что в Redis уже есть некоторые ключи от предыдущих запусков:

| Ключ | Значение | TTL (осталось) |
|------|---------|----------------|
| slot_dedup:a1b2c3... | "1" | 12h |
| slot_dedup:d4e5f6... | "1" | 8h |

Где:
- `a1b2c3...` это хэш для `Defence:Virtual:3:201:sub-001:MON:1`
- `d4e5f6...` это хэш для `Defence:Virtual:3:201:sub-002:TUE:3` (старый слот, которого нет в текущих результатах)

## Обработка подписок дедупликатором

### Подписка 1: user-charlie (sub-003)

**Matching timeslots:** `{"WED": [2]}`

#### Обработка слота WED-2

**Генерация ключа:**
```
Входные данные: Defence:Virtual:3:201:sub-003:WED:2
SHA3-256 хэш: 7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b
Финальный ключ: slot_dedup:7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b
```

**Проверка существования в Redis:**
```
EXISTS slot_dedup:7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b
Результат: 0 (ключ не существует)
```

**Действие:** Ключ не найден → это новый слот
```
SET slot_dedup:7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b "1" EX 86400
hasNewSlot = true
```

**Итог для sub-003:** Есть хотя бы один новый слот → подписка добавляется в результат ✓

---

### Подписка 2: user-bob (sub-002)

**Matching timeslots:** `{"MON": [1]}`

#### Обработка слота MON-1

**Генерация ключа:**
```
Входные данные: Defence:Virtual:3:201:sub-002:MON:1
SHA3-256 хэш: 1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b
Финальный ключ: slot_dedup:1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b
```

**Проверка существования в Redis:**
```
EXISTS slot_dedup:1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b
Результат: 0 (ключ не существует)
```

**Действие:** Ключ не найден → это новый слот
```
SET slot_dedup:1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b "1" EX 86400
hasNewSlot = true
```

**Итог для sub-002:** Есть хотя бы один новый слот → подписка добавляется в результат ✓

---

### Подписка 3: user-alice (sub-001)

**Matching timeslots:** `{"MON": [1, 2, 3], "WED": [2]}`

#### Обработка слота MON-1

**Генерация ключа:**
```
Входные данные: Defence:Virtual:3:201:sub-001:MON:1
SHA3-256 хэш: a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2
Финальный ключ: slot_dedup:a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2
```

**Проверка существования в Redis:**
```
EXISTS slot_dedup:a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2
Результат: 1 (ключ существует!)
```

**Действие:** Ключ найден → это старый слот, обновляем TTL
```
EXPIRE slot_dedup:a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2 86400
hasNewSlot остаётся false
```

#### Обработка слота MON-2

**Генерация ключа:**
```
Входные данные: Defence:Virtual:3:201:sub-001:MON:2
SHA3-256 хэш: b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3
Финальный ключ: slot_dedup:b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3
```

**Проверка существования в Redis:**
```
EXISTS slot_dedup:b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3
Результат: 0 (ключ не существует)
```

**Действие:** Ключ не найден → это новый слот
```
SET slot_dedup:b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3 "1" EX 86400
hasNewSlot = true
```

#### Обработка слота MON-3

**Генерация ключа:**
```
Входные данные: Defence:Virtual:3:201:sub-001:MON:3
SHA3-256 хэш: c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4
Финальный ключ: slot_dedup:c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4
```

**Проверка существования в Redis:**
```
EXISTS slot_dedup:c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4
Результат: 0 (ключ не существует)
```

**Действие:** Ключ не найден → это новый слот
```
SET slot_dedup:c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4 "1" EX 86400
hasNewSlot уже true
```

#### Обработка слота WED-2

**Генерация ключа:**
```
Входные данные: Defence:Virtual:3:201:sub-001:WED:2
SHA3-256 хэш: d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5
Финальный ключ: slot_dedup:d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5
```

**Проверка существования в Redis:**
```
EXISTS slot_dedup:d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5
Результат: 0 (ключ не существует)
```

**Действие:** Ключ не найден → это новый слот
```
SET slot_dedup:d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5 "1" EX 86400
hasNewSlot уже true
```

**Итог для sub-001:** Есть хотя бы один новый слот (на самом деле 3 из 4) → подписка добавляется в результат ✓

---

## Финальный результат дедупликации

| user_uuid | subscription_uuid | successful_subscriptions | last_successful_subscription | matching_timeslots |
|-----------|------------------|-------------------------|----------------------------|-------------------|
| user-charlie | sub-003 | 0 | NULL | {"WED": [2]} |
| user-bob | sub-002 | 2 | 2025-01-05 | {"MON": [1]} |
| user-alice | sub-001 | 5 | 2025-01-10 | {"MON": [1, 2, 3], "WED": [2]} |

Все три подписки прошли дедупликацию, потому что у каждой есть хотя бы один новый слот.

**Важно:** Несмотря на то, что слот MON-1 для user-alice уже был в кэше, подписка всё равно добавлена в результат, потому что слоты MON-2, MON-3 и WED-2 новые. В результат попадает вся подписка со всеми её слотами, а не только новые слоты.

---

## Состояние Redis кэша (после дедупликации)

| Ключ | Значение | TTL | Описание |
|------|---------|-----|----------|
| slot_dedup:a1b2c3... | "1" | 24h | Defence:Virtual:3:201:sub-001:MON:1 (TTL обновлён) |
| slot_dedup:b2c3d4... | "1" | 24h | Defence:Virtual:3:201:sub-001:MON:2 (новый) |
| slot_dedup:c3d4e5... | "1" | 24h | Defence:Virtual:3:201:sub-001:MON:3 (новый) |
| slot_dedup:d4e5f6... | "1" | 8h → expires | Defence:Virtual:3:201:sub-002:TUE:3 (старый, не обновлён) |
| slot_dedup:d4e5f6...² | "1" | 24h | Defence:Virtual:3:201:sub-001:WED:2 (новый) |
| slot_dedup:7a8b9c... | "1" | 24h | Defence:Virtual:3:201:sub-003:WED:2 (новый) |
| slot_dedup:1a2b3c... | "1" | 24h | Defence:Virtual:3:201:sub-002:MON:1 (новый) |

Обратите внимание что старый ключ `Defence:Virtual:3:201:sub-002:TUE:3` не был обновлён и его TTL продолжает истекать, так как этот слот не присутствовал в текущих результатах матчинга.

---

## Сценарий повторного запуска

Предположим, что через минуту приходят точно такие же слоты (те же самые AvailableSlots). Что произойдёт?

### Подписка user-charlie (sub-003), слот WED-2

**Проверка:**
```
EXISTS slot_dedup:7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b
Результат: 1 (ключ существует!)
```

**Действие:**
```
EXPIRE slot_dedup:7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b 86400
hasNewSlot = false
```

### Подписка user-bob (sub-002), слот MON-1

**Проверка:**
```
EXISTS slot_dedup:1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b
Результат: 1 (ключ существует!)
```

**Действие:**
```
EXPIRE slot_dedup:1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b 86400
hasNewSlot = false
```

### Подписка user-alice (sub-001), все слоты

Все четыре слота (MON-1, MON-2, MON-3, WED-2) теперь существуют в кэше. Для каждого будет выполнено:
```
EXISTS → Результат: 1
EXPIRE → TTL обновлён до 24h
hasNewSlot остаётся false
```

### Финальный результат повторного запуска

**Пустой массив!** `[]`

Все три подписки отфильтрованы, потому что у них нет ни одного нового слота.

---

## Сценарий с новой подпиской

Теперь представим что появился новый пользователь user-diana с подпиской sub-004 на те же параметры Defence/Virtual/3/201.

### Результат матчинга

| user_uuid | subscription_uuid | successful_subscriptions | last_successful_subscription | matching_timeslots |
|-----------|------------------|-------------------------|----------------------------|-------------------|
| user-diana | sub-004 | 0 | NULL | {"MON": [1]} |

### Обработка дедупликатором

#### Слот MON-1 для sub-004

**Генерация ключа:**
```
Входные данные: Defence:Virtual:3:201:sub-004:MON:1
SHA3-256 хэш: e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6
Финальный ключ: slot_dedup:e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6
```

**Важно:** Хэш отличается от хэша для sub-001:MON:1, потому что в генерацию ключа входит subscription_uuid!

**Проверка:**
```
EXISTS slot_dedup:e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6
Результат: 0 (ключ не существует)
```

**Действие:**
```
SET slot_dedup:e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6 "1" EX 86400
hasNewSlot = true
```

### Результат

| user_uuid | subscription_uuid | successful_subscriptions | last_successful_subscription | matching_timeslots |
|-----------|------------------|-------------------------|----------------------------|-------------------|
| user-diana | sub-004 | 0 | NULL | {"MON": [1]} |

Подписка добавлена в результат! Несмотря на то что слот MON-1 для других подписок уже был показан, для новой подписки sub-004 этот слот считается новым, потому что ключ включает subscription_uuid.

---

## Почему возвращаются все слоты, а не только новые?

В текущей реализации, если у подписки есть хотя бы один новый слот, в результат попадают **все** слоты этой подписки, а не только новые. Это сознательное архитектурное решение, основанное на практических соображениях.

### Проблема динамического состояния слотов

Рассмотрим типичный сценарий:

**Момент T1 (10:00):** Система обнаруживает доступные слоты MON-1 и MON-2 для user-alice
- Оба слота новые
- Пользователю отправлено уведомление: "Доступны слоты: понедельник 1-я пара, понедельник 2-я пара"
- Оба слота добавлены в Redis кэш

**Момент T2 (10:05):** Пользователь alice пытается записаться на MON-1
- Слот уже занят другим пользователем
- Попытка неудачна

**Момент T3 (10:10):** Другой пользователь отменяет запись с MON-1
- Слот снова становится доступным
- Система обнаруживает его при следующем поллинге

**Момент T4 (10:15):** Следующий запуск системы обнаруживает те же слоты MON-1 и MON-2
- **Если бы мы возвращали только новые слоты**: результат был бы пустым, так как оба слота уже в кэше
- Alice не получит уведомление о том, что MON-1 снова доступен
- **С текущей реализацией**: Если появится новый слот MON-3, alice увидит все три: MON-1, MON-2, MON-3

### Преимущества текущего подхода

#### 1. Повторная попытка записи на ранее недоступные слоты

Между моментом обнаружения слота и попыткой записи могут произойти изменения:
- Слот был занят → освободился
- Слот был доступен → занят → снова освободился
- Технический сбой при первой попытке записи

Возвращая все доступные слоты при появлении нового, мы даём пользователю или системе возможность повторить попытку записи на слоты, которые могли измениться.

#### 2. Улучшенный UX уведомлений

С точки зрения пользовательского опыта:
- Пользователь мог забыть какие слоты были доступны ранее
- Визуально понятнее видеть полную картину: "Для вашей подписки доступны: MON-1, MON-2, MON-3"
- Вместо сбивающего с толку: "Появился новый слот: MON-3" (а что было до этого?)

#### 3. Идемпотентность попыток записи

При автоматизированной записи на слоты:
- Система может пытаться записаться на все доступные слоты
- Если одна попытка неудачна (слот занят), система попробует следующий
- При появлении нового слота, система снова попробует все доступные - вдруг что-то изменилось

---

## Резюме работы дедупликатора

1. **Генерация уникальных ключей**: Для каждой комбинации (LabType, LabTopic, LabNumber, LabAuditorium, SubscriptionUUID, Day, Lesson) генерируется SHA3-256 хэш с префиксом.

2. **Проверка в Redis**: Каждый ключ проверяется на существование в кэше.

3. **Обработка существующих ключей**: Если ключ существует → обновляем его TTL, но не считаем слот новым.

4. **Обработка новых ключей**: Если ключ не существует → добавляем в кэш с TTL и помечаем что у подписки есть новый слот.

5. **Фильтрация результатов**: В финальный результат попадают только те подписки у которых hasNewSlot = true, но со **всеми** их доступными слотами, а не только новыми.

6. **Персональность для подписок**: Благодаря включению subscription_uuid в ключ, каждая подписка отслеживается независимо. Если появляется новая подписка, для неё все слоты будут новыми, даже если другие подписки их уже видели.

7. **Автоматическая очистка**: Ключи с истёкшим TTL автоматически удаляются из Redis, что позволяет показывать "забытые" слоты снова через заданный период времени.